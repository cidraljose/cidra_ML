{% extends 'base.html' %}

{% block title %}Make Predictions - {{ block.super }}{% endblock %}

{% block content %}
<!-- Tab Navigation -->
<ul class="nav nav-tabs" id="predictingTab" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="predict-tab" data-bs-toggle="tab" data-bs-target="#predict-panel" type="button" role="tab" aria-controls="predict-panel" aria-selected="true">
            Make a Prediction
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="history-tab" data-bs-toggle="tab" data-bs-target="#history-panel" type="button" role="tab" aria-controls="history-panel" aria-selected="false">
            Prediction History
        </button>
    </li>
</ul>

<!-- Tab Content -->
<div class="tab-content" id="predictingTabContent">
    <!-- Prediction Panel -->
    <div class="tab-pane fade show active" id="predict-panel" role="tabpanel" aria-labelledby="predict-tab">
        <div class="row mt-3">
            <div class="col-md-8">
                <h2>Make a Prediction</h2>
                <p>Choose a method to provide data for prediction.</p>

                {% if messages %}
                    {% for message in messages %}
                        <div class="alert {% if message.tags %}alert-{{ message.tags }}{% endif %}">{{ message }}</div>
                    {% endfor %}
                {% endif %}

                <!-- Sub Tabs -->
                <ul class="nav nav-pills mb-3" id="pills-tab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="pills-dataset-tab" data-bs-toggle="pill" data-bs-target="#pills-dataset" type="button" role="tab" aria-controls="pills-dataset" aria-selected="true">From Dataset</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="pills-manual-tab" data-bs-toggle="pill" data-bs-target="#pills-manual" type="button" role="tab" aria-controls="pills-manual" aria-selected="false">Manual Entry</button>
                    </li>
                </ul>

                <div class="tab-content" id="pills-tabContent">
                    <!-- From Dataset Tab -->
                    <div class="tab-pane fade show active" id="pills-dataset" role="tabpanel" aria-labelledby="pills-dataset-tab">
                        <p>Select a trained model and a dataset to generate predictions for the entire file.</p>
                        <form method="post" novalidate>
                            {% csrf_token %}
                            {% for field in dataset_form %}
                                <div class="mb-3">
                                    {{ field.label_tag }}
                                    {{ field }}
                                    {% for error in field.errors %}
                                        <div class="invalid-feedback d-block">{{ error }}</div>
                                    {% endfor %}
                                </div>
                            {% endfor %}
                            <button type="submit" name="submit_dataset" class="btn btn-primary mt-3">Run Prediction on Dataset</button>
                        </form>
                    </div>

                    <!-- Manual Entry Tab -->
                    <div class="tab-pane fade" id="pills-manual" role="tabpanel" aria-labelledby="pills-manual-tab">
                        <p>Select a model, then enter the feature values for a single prediction.</p>
                        <form method="post" novalidate>
                            {% csrf_token %}
                            <div class="mb-3">
                                <input type="hidden" name="manual-model" id="id_manual_model_hidden">
                                {{ model_selection_form.model.label_tag }}
                                {{ model_selection_form.model }}
                                {% for error in model_selection_form.model.errors %}
                                    <div class="invalid-feedback d-block">{{ error }}</div>
                                {% endfor %}
                            </div>

                            <!-- Dynamic form fields will be inserted here -->
                            <div id="manual-features-form" class="mt-4"></div>

                            <button type="submit" name="submit_manual" id="submit_manual_button" class="btn btn-primary mt-3 d-none">Run Manual Prediction</button>
                        </form>
                    </div>
                </div>

            </div>

        </div>
    </div>

    <!-- History Panel -->
    <div class="tab-pane fade" id="history-panel" role="tabpanel" aria-labelledby="history-tab">
        <div class="mt-3">
            <h2>All Prediction Results</h2>
            {% if history %}
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Model</th>
                            <th>Input Dataset</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for result in history %}
                        <tr id="prediction-row-{{ result.id }}" data-status="{{ result.status }}">
                            {% include "_prediction_result_row_partial.html" %}
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            {% else %}
                <p class="text-muted">No prediction results found. Run a prediction to see its history here.</p>
            {% endif %}
        </div>
    </div>
</div>

<!-- Visualize Modal -->
<div class="modal fade" id="visualizeModal" tabindex="-1" aria-labelledby="visualizeModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="visualizeModalLabel">Visualize Prediction Result</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="visualizeModalBody">
        <!-- Content will be loaded here by JavaScript -->
        <div class="text-center">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
{{ block.super }}
<script>
document.addEventListener('DOMContentLoaded', function () {
    // --- Tab Management ---
    // On page load, check if there's a URL hash and activate the corresponding tab.
    const hash = window.location.hash;
    if (hash) {
        const tabToActivate = document.querySelector(`button[data-bs-target="${hash}"]`);
        if (tabToActivate) {
            new bootstrap.Tab(tabToActivate).show();
        }
    }

    // --- Visualize Modal Logic ---
    const visualizeModal = document.getElementById('visualizeModal');
    if (visualizeModal) {
        visualizeModal.addEventListener('show.bs.modal', async function (event) {
            const button = event.relatedTarget;
            const resultId = button.getAttribute('data-result-id');
            const modalBody = document.getElementById('visualizeModalBody');
            const url = `/predicting/visualize/${resultId}/`;

            // Show loading spinner
            modalBody.innerHTML = `<div class="text-center"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></div>`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load visualization content.');
                const html = await response.text();
                modalBody.innerHTML = html;

            } catch (error) {
                modalBody.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        });

        // Use event delegation for the form inside the modal.
        // This listener is on the modal body and will catch submit events from any form within it.
        const modalBody = document.getElementById('visualizeModalBody');
        modalBody.addEventListener('submit', async function(e) {
            // Check if the event was triggered by our form
            if (e.target && e.target.id === 'visualize-form') {
                e.preventDefault(); // Prevent default full-page submission

                const form = e.target;
                const url = form.action; // The form's action attribute holds the correct URL
                const formData = new FormData(form);

                const response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    headers: { 'X-CSRFToken': formData.get('csrfmiddlewaretoken') }
                });
                const newHtml = await response.text();
                modalBody.innerHTML = newHtml; // Replace the modal content with the new response
            }
        });
    }

    // --- Manual Prediction Form Generation ---
    const modelSelect = document.getElementById('id_model_manual');
    const featuresFormContainer = document.getElementById('manual-features-form');
    const hiddenModelInput = document.getElementById('id_manual_model_hidden');
    const manualSubmitButton = document.getElementById('submit_manual_button');

    modelSelect.addEventListener('change', function() {
        const modelId = this.value;
        featuresFormContainer.innerHTML = ''; // Clear previous form
        manualSubmitButton.classList.add('d-none'); // Hide submit button

        if (modelId) {
            hiddenModelInput.value = modelId; // Keep hidden input in sync
            fetch(`/predicting/get-model-features/${modelId}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        const features = data.features;
                        let formHtml = `
                            <h5>Enter Feature Values</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered" id="manual-prediction-table">
                                    <thead>
                                        <tr>
                                            <th style="width: 1%;">#</th>`;
                        features.forEach(feature => {
                            formHtml += `<th>${feature}</th>`;
                        });
                        formHtml += `<th style="width: 1%;"></th>`; // For delete button
                        formHtml += `
                                        </tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                            </div>
                            <button type="button" id="add-row-btn" class="btn btn-sm btn-success">+</button>
                            `;
                        featuresFormContainer.innerHTML = formHtml;
                        manualSubmitButton.classList.remove('d-none'); // Show submit button
                    } else {
                        // This case handles a valid response but with no features
                        featuresFormContainer.innerHTML = '<p class="text-warning">This model has no features defined.</p>';
                    }
                })
                .then(() => {
                    // This runs after the table structure is in the DOM
                    const addRowBtn = document.getElementById('add-row-btn');
                    if (addRowBtn) {
                        // Add the first row automatically
                        addRow(); 

                        addRowBtn.addEventListener('click', addRow);

                        // Event delegation for delete buttons
                        const tableBody = document.querySelector('#manual-prediction-table tbody');
                        tableBody.addEventListener('click', function(e) {
                            // Use .closest() to handle clicks on the icon inside the button
                            const deleteButton = e.target.closest('.delete-row-btn');
                            if (deleteButton) {
                                // Prevent deleting the last row
                                if (tableBody.rows.length > 1) {
                                    e.target.closest('tr').remove();
                                    updateRowIndices();
                                } else {
                                    alert("You cannot delete the last row.");
                                }
                            }
                        });
                    }
                    else {
                        console.log("Could not find add row button");
                    }
                })
                .catch(error => {
                    console.error('Error fetching model features:', error);
                    // Display a more informative error to the user
                    featuresFormContainer.innerHTML = '<p class="text-danger">An error occurred while fetching model features. Please check the console for details or try again.</p>';
                });
        }
    });

    if (modelSelect.value) {
        modelSelect.dispatchEvent(new Event('change'));
    }

    function addRow() {
        const tableBody = document.querySelector('#manual-prediction-table tbody');
        if (!tableBody) return;

        const features = Array.from(document.querySelectorAll('#manual-prediction-table thead th'))
                              .map(th => th.textContent)
                              .filter(text => text && text !== '#'); // Filter out empty and index headers
        const newRow = tableBody.insertRow();
        const rowIndex = tableBody.rows.length - 1;

        // Add index cell
        const indexCell = newRow.insertCell();
        indexCell.className = 'align-middle text-center';
        indexCell.textContent = rowIndex + 1;

        features.forEach(feature => {
            const cell = newRow.insertCell();
            cell.innerHTML = `<input type="text" name="${feature}[${rowIndex}]" class="form-control" required>`;
        });

        // Add delete button cell
        const deleteCell = newRow.insertCell();
        deleteCell.innerHTML = `<button type="button" class="btn btn-sm btn-danger delete-row-btn">-</button>`;
        deleteCell.style.textAlign = 'center';
    }

    function updateRowIndices() {
        const tableBody = document.querySelector('#manual-prediction-table tbody');
        if (!tableBody) return;

        // Update row indices in the first column
        Array.from(tableBody.rows).forEach((row, rowIndex) => {
            const indexCell = row.cells[0];
            indexCell.textContent = rowIndex + 1;
        });

        Array.from(tableBody.rows).forEach((row, rowIndex) => {
            row.querySelectorAll('input').forEach(input => {
                const name = input.name.substring(0, input.name.lastIndexOf('['));
                if (name) {
                    input.name = `${name}[${rowIndex}]`;
                }
            });
        });
    }

    // --- Live Status Polling for Prediction Results ---
    const activePollers = new Map();
    const pollingInterval = 10000;

    const pollStatus = async (resultId, rowElement) => {
        // This URL needs to be created in predicting/urls.py and predicting/views.py
        const url = `{% url 'get_prediction_result_row_partial_view' 0 %}`.replace('0', resultId);

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Server error: ${response.status}`);
            
            const newRowHtml = await response.text();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<table><tbody><tr data-status="TEMP">${newRowHtml}</tr></tbody></table>`;
            const newStatus = tempDiv.querySelector('tr').dataset.status;

            // Replace the old row content with the new one.
            rowElement.innerHTML = newRowHtml;
            rowElement.dataset.status = newStatus; // Update the status attribute

            // If the new status is final, stop polling.
            if (newStatus === 'COMPLETED' || newStatus === 'FAILED') {
                clearInterval(activePollers.get(resultId));
                activePollers.delete(resultId);
            }
        } catch (error) {
            console.error(`Failed to poll status for result ${resultId}:`, error);
            clearInterval(activePollers.get(resultId)); // Stop on error
            activePollers.delete(resultId);
        }
    };

    // Find all rows that are currently pending or running and start polling them.
    document.querySelectorAll('tr[data-status="PENDING"], tr[data-status="RUNNING"]').forEach(row => {
        const resultId = row.id.split('-').pop();
        if (resultId && !activePollers.has(resultId)) {
            const intervalId = setInterval(() => pollStatus(resultId, row), pollingInterval);
            activePollers.set(resultId, intervalId);
        }
    });
});
</script>
{% endblock %}